####################### Temperature lags #######################


### Define neighbourhood matrix
ecuador <- getData('GADM', country = "ECU", level = 2)
el_oro  <- subset(ecuador, NAME_1 == "El Oro")

## Create neighbourhood matrix
nb.map <- poly2nb(el_oro)
nb2INLA("map.graph",nb.map)

## Read in data
data <- read.csv("data/inla_input/data.csv")
data$cases <- as.numeric(data$cases)


# Separate parasite models
data_pf <- subset(data, data$parasite == "Falciparum")
data_pv <- subset(data, data$parasite == "Vivax")

#######################################################################################################################################################

#### Falciparum models

## Fixed effects
y  <- data_pf$cases
n  <- length(y)

## Add API so modify offset to include it 
e  <- (data_pf$Population/12)/1000


## Climate effects, scaling the covariates
prcp <- scale(data_pf$prcp, center = TRUE, scale = TRUE)[,1] ## in mm/day
tmax <- scale(data_pf$tmax, center = TRUE, scale = TRUE)[,1]
tmin <- scale(data_pf$tmin, center = TRUE, scale = TRUE)[,1]
urban <- scale(data_pf$urban, center = TRUE, scale = TRUE)[,1]

## Socioeconomic data
total_poverty <- scale(data_pf$total_poverty, center = TRUE, scale = TRUE)[,1]

blocks_fumigated <- scale(data_pf$blocks_fumigated, center = TRUE, scale = TRUE)[,1] 
houses_IRS    <- scale(data_pf$houses_IRS, center = TRUE, scale = TRUE)[,1]
houses_fogged <- scale(data_pf$houses_fogged, center = TRUE, scale = TRUE)[,1]

### Random effects
# Temporal
t1 <- as.factor(data_pf$Month) # Seasonality
t2 <- as.factor(data_pf$Year)  # Interannual 

# Spatial effects
s1 <- rep(1:14, 348) 


##################################
# tmin - add time lags
tmin <- scale(data_pf$tmin, center = TRUE, scale = TRUE)[,1]
tmin_lag1 <- scale(data_pf$tmin_lag1, center = TRUE, scale = TRUE)[,1]
tmin_lag2 <- scale(data_pf$tmin_lag2, center = TRUE, scale = TRUE)[,1]
tmin_lag3 <- scale(data_pf$tmin_lag3, center = TRUE, scale = TRUE)[,1]

df_inla_pf <- data.frame(y, prcp, tmax, tmin, tmin_lag1,
                         tmin_lag2, tmin_lag3, 
                         t1, t2, s1, total_poverty, urban)


###########################################################################################################
## Test with all other covariates
formula <- y ~ 1 + f(s1, model = "bym2", graph = "map.graph") +
  f(t1, model = "rw1") +
  f(t2, model = "iid") +
  tmin +
  prcp + 
  urban +
  total_poverty 


mod_tmin_lag0_l_pf <- inla(formula, data = df_inla_pf, family = "zeroinflatednbinomial0", 
                           offset = log(e), verbose = TRUE,
                           #control.inla = list(strategy = 'adaptive'),
                           control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE, 
                                                  config = FALSE, # turn on when computing post. pred
                                                  return.marginals = FALSE), # turn on if using marginals
                           control.predictor = list(link = 1, compute = TRUE), 
                           control.family = list(link = "log"))

formula <- y ~ 1 + f(s1, model = "bym2", graph = "map.graph") +
  f(t1, model = "rw1") +
  f(t2, model = "iid") +
  f(inla.group(tmin), model = "rw1") +
  f(inla.group(prcp), model = "rw1") + 
  urban +
  total_poverty 

mod_tmin_lag0_nl_pf <- inla(formula, data = df_inla_pf, family = "zeroinflatednbinomial0", 
                            offset = log(e), verbose = TRUE,
                            #control.inla = list(strategy = 'adaptive'),
                            control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE, 
                                                   config = FALSE, # turn on when computing post. pred
                                                   return.marginals = FALSE), # turn on if using marginals
                            control.predictor = list(link = 1, compute = TRUE), 
                            control.family = list(link = "log"))

formula <- y ~ 1 + f(s1, model = "bym2", graph = "map.graph") +
  f(t1, model = "rw1") +
  f(t2, model = "iid") +
  tmin_lag1 +
  prcp + 
  urban +
  total_poverty 


mod_tmin_lag1_l_pf <- inla(formula, data = df_inla_pf, family = "zeroinflatednbinomial0", 
                           offset = log(e), verbose = TRUE,
                           #control.inla = list(strategy = 'adaptive'),
                           control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE, 
                                                  config = FALSE, # turn on when computing post. pred
                                                  return.marginals = FALSE), # turn on if using marginals
                           control.predictor = list(link = 1, compute = TRUE), 
                           control.family = list(link = "log"))

formula <- y ~ 1 + f(s1, model = "bym2", graph = "map.graph") +
  f(t1, model = "rw1") +
  f(t2, model = "iid") +
  f(inla.group(tmin_lag1), model = "rw1") +
  f(inla.group(prcp), model = "rw1") + 
  urban +
  total_poverty 


mod_tmin_lag1_nl_pf <- inla(formula, data = df_inla_pf, family = "zeroinflatednbinomial0", 
                            offset = log(e), verbose = TRUE,
                            #control.inla = list(strategy = 'adaptive'),
                            control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE, 
                                                   config = FALSE, # turn on when computing post. pred
                                                   return.marginals = FALSE), # turn on if using marginals
                            control.predictor = list(link = 1, compute = TRUE), 
                            control.family = list(link = "log"))

formula <- y ~ 1 + f(s1, model = "bym2", graph = "map.graph") +
  f(t1, model = "rw1") +
  f(t2, model = "iid") +
  tmin_lag2 +
  prcp + 
  urban +
  total_poverty 


mod_tmin_lag2_l_pf <- inla(formula, data = df_inla_pf, family = "zeroinflatednbinomial0", 
                           offset = log(e), verbose = TRUE,
                           #control.inla = list(strategy = 'adaptive'),
                           control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE, 
                                                  config = FALSE, # turn on when computing post. pred
                                                  return.marginals = FALSE), # turn on if using marginals
                           control.predictor = list(link = 1, compute = TRUE), 
                           control.family = list(link = "log"))

formula <- y ~ 1 + f(s1, model = "bym2", graph = "map.graph") +
  f(t1, model = "rw1") +
  f(t2, model = "iid") +
  f(inla.group(tmin_lag2), model = "rw1") +
  f(inla.group(prcp), model = "rw1") + 
  urban +
  total_poverty 


mod_tmin_lag2_nl_pf <- inla(formula, data = df_inla_pf, family = "zeroinflatednbinomial0", 
                            offset = log(e), verbose = TRUE,
                            #control.inla = list(strategy = 'adaptive'),
                            control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE, 
                                                   config = FALSE, # turn on when computing post. pred
                                                   return.marginals = FALSE), # turn on if using marginals
                            control.predictor = list(link = 1, compute = TRUE), 
                            control.family = list(link = "log"))


formula <- y ~ 1 + f(s1, model = "bym2", graph = "map.graph") +

  f(t1, model = "rw1") +
  f(t2, model = "iid") +
  tmin_lag3 +
  prcp + 
  urban +
  total_poverty 


mod_tmin_lag3_l_pf <- inla(formula, data = df_inla_pf, family = "zeroinflatednbinomial0", 
                           offset = log(e), verbose = TRUE,
                           #control.inla = list(strategy = 'adaptive'),
                           control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE, 
                                                  config = FALSE, # turn on when computing post. pred
                                                  return.marginals = FALSE), # turn on if using marginals
                           control.predictor = list(link = 1, compute = TRUE), 
                           control.family = list(link = "log"))

formula <- y ~ 1 + f(s1, model = "bym2", graph = "map.graph") +
  f(t1, model = "rw1") +
  f(t2, model = "iid") +
  f(inla.group(tmin_lag3), model = "rw1") +
  f(inla.group(prcp), model = "rw1") + 
  urban +
  total_poverty 


mod_tmin_lag3_nl_pf <- inla(formula, data = df_inla_pf, family = "zeroinflatednbinomial0", 
                            offset = log(e), verbose = TRUE,
                            #control.inla = list(strategy = 'adaptive'),
                            control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE, 
                                                   config = FALSE, # turn on when computing post. pred
                                                   return.marginals = FALSE), # turn on if using marginals
                            control.predictor = list(link = 1, compute = TRUE), 
                            control.family = list(link = "log"))


#######################################################################################################################################################

#### Vivax models

## Fixed effects
y  <- data_pv$cases
n  <- length(y)

## Add API so modify offset to include it 
e  <- (data_pv$Population/12)/1000


## Climate effects, scaling the covariates
prcp <- scale(data_pv$prcp, center = TRUE, scale = TRUE)[,1] ## in mm/day
tmax <- scale(data_pv$tmax, center = TRUE, scale = TRUE)[,1]
tmin <- scale(data_pv$tmin, center = TRUE, scale = TRUE)[,1]

urban <- scale(data_pv$urban, center = TRUE, scale = TRUE)[,1]

## Socioeconomic data_pv
total_poverty <- scale(data_pv$total_poverty, center = TRUE, scale = TRUE)[,1]

blocks_fumigated <- scale(data_pv$blocks_fumigated, center = TRUE, scale = TRUE)[,1]
houses_IRS    <- scale(data_pv$houses_IRS, center = TRUE, scale = TRUE)[,1]
houses_fogged <- scale(data_pv$houses_fogged, center = TRUE, scale = TRUE)[,1]

### Random effects
# Temporal
t1 <- as.factor(data_pv$Month) # Seasonality
t2 <- as.factor(data_pv$Year)  # Interannual 

# Spatial
s1 <- rep(1:14, 348) 


##################################
# tmin - add time lags
tmin <- scale(data_pv$tmin, center = TRUE, scale = TRUE)[,1]
tmin_lag1 <- scale(data_pv$tmin_lag1, center = TRUE, scale = TRUE)[,1]
tmin_lag2 <- scale(data_pv$tmin_lag2, center = TRUE, scale = TRUE)[,1]
tmin_lag3 <- scale(data_pv$tmin_lag3, center = TRUE, scale = TRUE)[,1]

df_inla_pv <- data.frame(y, prcp, tmin, tmin_lag1,
                         tmin_lag2, tmin_lag3, tmax,
                         t1, t2, s1, urban, total_poverty)

###########################################################################################################
## Test with all other covariates
formula <- y ~ 1 + f(s1, model = "bym2", graph = "map.graph") +
  f(t1, model = "rw1") +
  f(t2, model = "iid") +
  tmin +
  prcp + 
  urban +
  total_poverty 


mod_tmin_lag0_l_pv <- inla(formula, data = df_inla_pv, family = "zeroinflatednbinomial0", 
                           offset = log(e), verbose = TRUE,
                           #control.inla = list(strategy = 'adaptive'),
                           control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE, 
                                                  config = FALSE, # turn on when computing post. pred
                                                  return.marginals = FALSE), # turn on if using marginals
                           control.predictor = list(link = 1, compute = TRUE), 
                           control.family = list(link = "log"))

formula <- y ~ 1 + f(s1, model = "bym2", graph = "map.graph") +
  f(t1, model = "rw1") +
  f(t2, model = "iid") +
  f(inla.group(tmin), model = "rw1") +
  f(inla.group(prcp), model = "rw1") + 
  urban +
  total_poverty 

mod_tmin_lag0_nl_pv <- inla(formula, data = df_inla_pv, family = "zeroinflatednbinomial0", 
                            offset = log(e), verbose = TRUE,
                            #control.inla = list(strategy = 'adaptive'),
                            control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE, 
                                                   config = FALSE, # turn on when computing post. pred
                                                   return.marginals = FALSE), # turn on if using marginals
                            control.predictor = list(link = 1, compute = TRUE), 
                            control.family = list(link = "log"))

formula <- y ~ 1 + f(s1, model = "bym2", graph = "map.graph") +
  f(t1, model = "rw1") +
  f(t2, model = "iid") +
  tmin_lag1 +
  prcp + 
  urban +
  total_poverty 


mod_tmin_lag1_l_pv <- inla(formula, data = df_inla_pv, family = "zeroinflatednbinomial0", 
                           offset = log(e), verbose = TRUE,
                           #control.inla = list(strategy = 'adaptive'),
                           control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE, 
                                                  config = FALSE, # turn on when computing post. pred
                                                  return.marginals = FALSE), # turn on if using marginals
                           control.predictor = list(link = 1, compute = TRUE), 
                           control.family = list(link = "log"))

formula <- y ~ 1 + f(s1, model = "bym2", graph = "map.graph") +
  f(t1, model = "rw1") +
  f(t2, model = "iid") +
  f(inla.group(tmin_lag1), model = "rw1") +
  f(inla.group(prcp), model = "rw1") + 
  urban +
  total_poverty 


mod_tmin_lag1_nl_pv <- inla(formula, data = df_inla_pv, family = "zeroinflatednbinomial0", 
                            offset = log(e), verbose = TRUE,
                            #control.inla = list(strategy = 'adaptive'),
                            control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE, 
                                                   config = FALSE, # turn on when computing post. pred
                                                   return.marginals = FALSE), # turn on if using marginals
                            control.predictor = list(link = 1, compute = TRUE), 
                            control.family = list(link = "log"))

formula <- y ~ 1 + f(s1, model = "bym2", graph = "map.graph") +

  f(t1, model = "rw1") +
  f(t2, model = "iid") +
  tmin_lag2 +
  prcp + 
  urban +
  total_poverty 


mod_tmin_lag2_l_pv <- inla(formula, data = df_inla_pv, family = "zeroinflatednbinomial0", 
                           offset = log(e), verbose = TRUE,
                           #control.inla = list(strategy = 'adaptive'),
                           control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE, 
                                                  config = FALSE, # turn on when computing post. pred
                                                  return.marginals = FALSE), # turn on if using marginals
                           control.predictor = list(link = 1, compute = TRUE), 
                           control.family = list(link = "log"))

formula <- y ~ 1 + f(s1, model = "bym2", graph = "map.graph") +
  f(t1, model = "rw1") +
  f(t2, model = "iid") +
  f(inla.group(tmin_lag2), model = "rw1") +
  f(inla.group(prcp), model = "rw1") + 
  urban +
  total_poverty 


mod_tmin_lag2_nl_pv <- inla(formula, data = df_inla_pv, family = "zeroinflatednbinomial0", 
                            offset = log(e), verbose = TRUE,
                            #control.inla = list(strategy = 'adaptive'),
                            control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE, 
                                                   config = FALSE, # turn on when computing post. pred
                                                   return.marginals = FALSE), # turn on if using marginals
                            control.predictor = list(link = 1, compute = TRUE), 
                            control.family = list(link = "log"))


formula <- y ~ 1 + f(s1, model = "bym2", graph = "map.graph") +

  f(t1, model = "rw1") +
  f(t2, model = "iid") +
  tmin_lag3 +
  prcp + 
  urban +
  total_poverty 


mod_tmin_lag3_l_pv <- inla(formula, data = df_inla_pv, family = "zeroinflatednbinomial0", 
                           offset = log(e), verbose = TRUE,
                           #control.inla = list(strategy = 'adaptive'),
                           control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE, 
                                                  config = FALSE, # turn on when computing post. pred
                                                  return.marginals = FALSE), # turn on if using marginals
                           control.predictor = list(link = 1, compute = TRUE), 
                           control.family = list(link = "log"))

formula <- y ~ 1 + f(s1, model = "bym2", graph = "map.graph") +
  f(t1, model = "rw1") +
  f(t2, model = "iid") +
  f(inla.group(tmin_lag3), model = "rw1") +
  f(inla.group(prcp), model = "rw1") + 
  urban +
  total_poverty 


mod_tmin_lag3_nl_pv <- inla(formula, data = df_inla_pv, family = "zeroinflatednbinomial0", 
                            offset = log(e), verbose = TRUE,
                            #control.inla = list(strategy = 'adaptive'),
                            control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE, 
                                                   config = FALSE, # turn on when computing post. pred
                                                   return.marginals = FALSE), # turn on if using marginals
                            control.predictor = list(link = 1, compute = TRUE), 
                            control.family = list(link = "log"))


########################################################################################################


########################################################################################################

### Model summaries

tmin_table <- data.frame(Parasite = c(rep("P. falciparum", 4),
                                      rep("P. vivax", 4),
                                      rep("P. falciparum", 4),
                                      rep("P. vivax", 4)),
                         
                         Lag = c(0:3, 0:3, 0:3, 0:3),
                         
                         Relationship = c(rep("Linear", 8),
                                          rep("Non-linear", 8)), 
                         
                         DIC      = c(mod_tmin_lag0_l_pf$dic$dic, mod_tmin_lag1_l_pf$dic$dic,
                                      mod_tmin_lag2_l_pf$dic$dic,mod_tmin_lag3_l_pf$dic$dic,
                                      
                                      mod_tmin_lag0_l_pv$dic$dic,mod_tmin_lag1_l_pv$dic$dic,
                                      mod_tmin_lag2_l_pv$dic$dic,mod_tmin_lag3_l_pv$dic$dic,
                                      
                                      mod_tmin_lag0_nl_pf$dic$dic,mod_tmin_lag1_nl_pf$dic$dic,
                                      mod_tmin_lag2_nl_pf$dic$dic,mod_tmin_lag3_nl_pf$dic$dic,
                                      
                                      mod_tmin_lag0_nl_pv$dic$dic,mod_tmin_lag1_nl_pv$dic$dic,
                                      mod_tmin_lag2_nl_pv$dic$dic,mod_tmin_lag3_nl_pv$dic$dic),
                         
                         WAIC      = c(mod_tmin_lag0_l_pf$waic$waic,mod_tmin_lag1_l_pf$waic$waic,
                                       mod_tmin_lag2_l_pf$waic$waic,mod_tmin_lag3_l_pf$waic$waic,
                                       
                                       mod_tmin_lag0_l_pv$waic$waic,mod_tmin_lag1_l_pv$waic$waic,
                                       mod_tmin_lag2_l_pv$waic$waic,mod_tmin_lag3_l_pv$waic$waic,
                                       
                                       mod_tmin_lag0_nl_pf$waic$waic,mod_tmin_lag1_nl_pf$waic$waic,
                                       mod_tmin_lag2_nl_pf$waic$waic,mod_tmin_lag3_nl_pf$waic$waic,
                                       
                                       mod_tmin_lag0_nl_pv$waic$waic,mod_tmin_lag1_nl_pv$waic$waic,
                                       mod_tmin_lag2_nl_pv$waic$waic,mod_tmin_lag3_nl_pv$waic$waic),
                         
                         Estimate = c(mod_tmin_lag0_l_pf$summary.fixed$mean[2],mod_tmin_lag1_l_pf$summary.fixed$mean[2],
                                      mod_tmin_lag2_l_pf$summary.fixed$mean[2],mod_tmin_lag3_l_pf$summary.fixed$mean[2],
                                      
                                      mod_tmin_lag0_l_pv$summary.fixed$mean[2],mod_tmin_lag1_l_pv$summary.fixed$mean[2],
                                      mod_tmin_lag2_l_pv$summary.fixed$mean[2],mod_tmin_lag3_l_pv$summary.fixed$mean[2],
                                      
                                      mod_tmin_lag0_nl_pf$summary.fixed$mean[2],mod_tmin_lag1_nl_pf$summary.fixed$mean[2],
                                      mod_tmin_lag2_nl_pf$summary.fixed$mean[2], mod_tmin_lag3_nl_pf$summary.fixed$mean[2],
                                      
                                      mod_tmin_lag0_nl_pv$summary.fixed$mean[2],mod_tmin_lag1_nl_pv$summary.fixed$mean[2],
                                      mod_tmin_lag2_nl_pv$summary.fixed$mean[2], mod_tmin_lag3_nl_pv$summary.fixed$mean[2]),
                         
                         LCI      = c(mod_tmin_lag0_l_pf$summary.fixed$`0.025quant`[2],mod_tmin_lag1_l_pf$summary.fixed$`0.025quant`[2],
                                      mod_tmin_lag2_l_pf$summary.fixed$`0.025quant`[2],mod_tmin_lag3_l_pf$summary.fixed$`0.025quant`[2],
                                      
                                      mod_tmin_lag0_l_pv$summary.fixed$`0.025quant`[2],mod_tmin_lag1_l_pv$summary.fixed$`0.025quant`[2],
                                      mod_tmin_lag2_l_pv$summary.fixed$`0.025quant`[2],mod_tmin_lag3_l_pv$summary.fixed$`0.025quant`[2],
                                      
                                      mod_tmin_lag0_nl_pf$summary.fixed$`0.025quant`[2],mod_tmin_lag1_nl_pf$summary.fixed$`0.025quant`[2],
                                      mod_tmin_lag2_nl_pf$summary.fixed$`0.025quant`[2],mod_tmin_lag3_nl_pf$summary.fixed$`0.025quant`[2],
                                      
                                      mod_tmin_lag0_nl_pv$summary.fixed$`0.025quant`[2],mod_tmin_lag1_nl_pv$summary.fixed$`0.025quant`[2],
                                      mod_tmin_lag2_nl_pv$summary.fixed$`0.025quant`[2],mod_tmin_lag3_nl_pv$summary.fixed$`0.025quant`[2]),
                         
                         UCI      = c(mod_tmin_lag0_l_pf$summary.fixed$`0.975quant`[2],mod_tmin_lag1_l_pf$summary.fixed$`0.975quant`[2],
                                      mod_tmin_lag2_l_pf$summary.fixed$`0.975quant`[2],mod_tmin_lag3_l_pf$summary.fixed$`0.975quant`[2],
                                      
                                      mod_tmin_lag0_l_pv$summary.fixed$`0.975quant`[2],mod_tmin_lag1_l_pv$summary.fixed$`0.975quant`[2],
                                      mod_tmin_lag2_l_pv$summary.fixed$`0.975quant`[2],mod_tmin_lag3_l_pv$summary.fixed$`0.975quant`[2],
                                      
                                      mod_tmin_lag0_nl_pf$summary.fixed$`0.975quant`[2],mod_tmin_lag1_nl_pf$summary.fixed$`0.975quant`[2],
                                      mod_tmin_lag2_nl_pf$summary.fixed$`0.975quant`[2],mod_tmin_lag3_nl_pf$summary.fixed$`0.975quant`[2],
                                      
                                      mod_tmin_lag0_nl_pv$summary.fixed$`0.975quant`[2],mod_tmin_lag1_nl_pv$summary.fixed$`0.975quant`[2],
                                      mod_tmin_lag2_nl_pv$summary.fixed$`0.975quant`[2],mod_tmin_lag3_nl_pv$summary.fixed$`0.975quant`[2]))


kable(tmin_table, caption = " ") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE, 
                font_size = 14) %>%
  collapse_rows(1:2, valign = "top") %>%
  save_kable("model_comparisons/tmin_lags.pdf")
